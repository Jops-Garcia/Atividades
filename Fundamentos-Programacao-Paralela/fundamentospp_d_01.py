# -*- coding: utf-8 -*-
"""FundamentosPP_D_01.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/15u50oDFl1LfK2U8LT1_HSDJ9J4s1UhMr

**Aula 3**

Após nossa primeira aula, onde discutimos os fundamentos da programação paralela, vamos relembrar conceitos de Programação concorrente.

# *Atividade 1*
Vamos relembrar o uso de threads

#**1.A**
Um programa só com a thread principal.
"""

#1. Definindo  o código a ser executado neste código, sincronamente.
#importando bibliotecas necessárias
import time
from threading import Thread

def do_something(sec):
  print('Doing Something...')
  time.sleep(sec)
  print('Done')


start=time.time()

do_something(1)

end=time.time()

print( f'Tempo decorrido:{end-start}')

"""#**1.B**
Um programa só com a thread principal, precisando fazer a mesma atividade múltiplas vezes de forma independente de ordem de execução
"""

#importando bibliotecas necessárias
import time
from threading import Thread
def do_something(sec):
  print('Doing Something...')
  time.sleep(sec)
  print('Done!')


start=time.time()

for _ in range(5):
   do_something(1)

end=time.time()

print( f'Tempo decorrido:{end-start}')

"""#**1.C**
Como tirar proveito  de múltiplos cores e threads da CPU?
"""

#importando bibliotecas necessárias
import time
from threading import Thread
# Agora sim com múltiplas  Threads.
def do_something(sec):
  print('Doing Something...')
  time.sleep(sec)
  print('Done!')


start=time.time()

for _ in range(5):
   new_thread = Thread(target=do_something, args=[1])
   new_thread.start()


end=time.time()

print( f'Tempo decorrido:{end-start}')

"""Ops!!
Algo estranho, não?

#**1.D**

Vamos pedir que o processo que contenha as threads só termine quando todas as threads terminarem
"""

#importando bibliotecas necessárias
import time
from threading import Thread
# Agora sim com múltiplas  Threads.
def do_something(sec):
  print('Doing Something...')
  time.sleep(sec)
  print('Done!')

threads=[]
start=time.time()

for _ in range(5):
   new_thread = Thread(target=do_something, args=[1])
   threads.append(new_thread)
   new_thread.start()

for t in threads:
  t.join()



end=time.time()

print( f'Tempo decorrido:{end-start}')

"""#**1.E**

Vamos encontrar o limite onde aumentando o número de threads  o tempo de conclusão fica maior que o tempo da Atividade  **1.B**
"""

# Agora sim com múltiplas  Threads.
#importando bibliotecas necessárias
import time
from threading import Thread
def do_something(sec):
  print('Doing Something...')
  time.sleep(sec)
  print('Done!')

threads=[]
start=time.time()

for _ in range(1000):
   new_thread = Thread(target=do_something, args=[1])
   threads.append(new_thread)
   new_thread.start()

for t in threads:
  t.join()



end=time.time()

print( f'Tempo decorrido:{end-start}')

"""# *Atividade 2*
Vamos realizar uma tarefa coletivamente

**2.A**

Com apenas uma thread (a principal)
"""



import time
import numpy as np
from threading import Thread,Lock
lista= np.random.randint(1000,None, size=10000, dtype=int)
result=0
start=time.time()
for i in lista:
  result= result +i

print("O resultado final  é:{}".format(result))
end=time.time()

print( f'Tempo decorrido:{end-start}')

import time
import numpy as np
import threading

# Gerando a lista de números aleatórios
lista = np.random.randint(1000, size=1000, dtype=int)

threads = []
result = 0
n_threads = 24

lock = threading.Lock()
bloco = len(lista) // n_threads

def some_suaparte(lst, idx, inic, fin):
    print('{0} - Somando minha parte: de {1} a {2}'.format(idx, inic, fin))
    global result
    minhasoma = sum(lst[inic:fin])
    print('{0} - Done! Minha soma: {1}'.format(idx, minhasoma))
    with lock:  # Usando 'with' para gerenciar o lock
        result += minhasoma

start = time.time()

for x in range(n_threads):
    inicio = x * bloco
    final = inicio + bloco if x < n_threads - 1 else len(lista)  # Último bloco pode ser maior
    new_thread = threading.Thread(target=some_suaparte, args=(lista, x, inicio, final))
    threads.append(new_thread)
    new_thread.start()

for t in threads:
    t.join()

print("O resultado final é: {}".format(result))
end = time.time()

print(f'Tempo decorrido: {end - start:.4f} segundos')